---
description: Defines metadata-based component generation rules for React + TypeScript projects. Focuses on development processes based on Event Storming stickers beyond basic project setup.
globs: Frontend-PRD.txt
alwaysApply: false
---
# Frontend Generation Rules

### Precautions
- Code generation must strictly follow all sequences specified in this file without any omissions.
- All steps from 1 to 8 must be completed. Step 7 (ERP Essential Features) and Step 8 (Validation) are mandatory.
- All component generation must be based on metadata and must be generated without omissions. However, components should not be arbitrarily generated by referring to non-existent metadata.
- Favicon errors occur frequently and proactive measures should be taken in advance.

### Step-by-step Component Generation Process
The project must be generated strictly following the numbered sequence below.

#### 1. Metadata Analysis, Validation and Package Structure Generation
- Analyze Aggregate(aggregates), Command(commands), ReadModel(views or readModels) metadata
- Organize Pages, Modals, Services, Types, Stores, Hooks that need to be generated accordingly
- Correct missing package structure by referring to `@frontend-architecture`

#### 2. Generate Aggregate-related Components
- Generate hooks, services, store, types components under src directory
- After completion, generate Pages components with Grid Table structure that handle CRUD operation buttons, and API Endpoints must be generated according to `/aggregate.namePlural` rule
- For Page components, Buttons and Modals corresponding to CUD (Create, Update, Delete) operations must be generated based on aggregateRoot.fieldDescriptors metadata

#### 3. Generate Command-related Components

**REQUIRED**: All Commands in wireframe.md must be generated without omission.

##### 3.1 Generate Modal Components

- Generate same number of Modal components as commands analyzed in Step 1
- File location: `src/components/[aggregate]/[Command]Modal.tsx`
- **UI Structure**: Strictly comply with Command HTML and fields declared in each `BoundedContext/Aggregate/wireframe.md`
- **API Endpoints**: Precisely follow endpoints defined in wireframe.md

**Modal Basic Structure (Core Only):**

```typescript
interface [Command]ModalProps {
  open: boolean;
  onClose: () => void;
  onSubmit: (command: [Command]Command) => Promise<void>;
  // Required parameters defined in wireframe.md
}

const [Command]Modal = ({ open, onClose, onSubmit, ... }: [Command]ModalProps) => {
  // 1. Form field state management
  const [field1, setField1] = useState<type>('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 2. Submit handler
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    try {
      await onSubmit({ field1, ... });
      handleClose();
    } catch (err: any) {
      setError(err.message || 'Operation failed.');
    } finally {
      setLoading(false);
    }
  };

  // 3. Close handler (reset state)
  const handleClose = () => {
    setField1('');
    setError(null);
    onClose();
  };

  return (
    <Dialog open={open} onClose={handleClose} maxWidth="sm" fullWidth>
      <DialogTitle>{/* Title from wireframe.md */}</DialogTitle>
      <form onSubmit={handleSubmit}>
        <DialogContent>
          {error && <Alert severity="error">{error}</Alert>}
          {/* HTML field structure from wireframe.md */}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose} disabled={loading}>Cancel</Button>
          <Button type="submit" variant="contained" disabled={loading}>
            {loading ? 'Processing...' : 'Confirm'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
};
```

##### 3.2 Integrate into AggregatePage

**Button Generation and Modal Invocation Pattern:**

```typescript
const [Aggregate]Page = () => {
  // 1. Open state for each Command Modal
  const [command1ModalOpen, setCommand1ModalOpen] = useState(false);
  const [command2ModalOpen, setCommand2ModalOpen] = useState(false);
  // ... Add as many as the number of Commands in wireframe.md

  // 2. Handler function for each Command
  const handleCommand1 = async (data: Command1Command) => {
    // API call logic (use API Endpoints from wireframe.md)
    await command1Service.execute(data);
    // Refresh data if necessary
  };

  return (
    <Box>
      {/* Quick Action Button Area */}
      <Paper sx=\{{ p: 2, mb: 3 }}>
        <Typography variant="subtitle1" fontWeight={500} sx=\{{ mb: 2 }}>
          Quick Actions
        </Typography>
        <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
          {/* Generate all Command buttons from wireframe.md */}
          <Button 
            variant="outlined" 
            size="small" 
            onClick={() => setCommand1ModalOpen(true)}
          >
            Command 1 Name
          </Button>
          <Button 
            variant="outlined" 
            size="small" 
            onClick={() => setCommand2ModalOpen(true)}
          >
            Command 2 Name
          </Button>
          {/* ... All Command buttons */}
        </Stack>
      </Paper>

      {/* Connect all Command Modals */}
      <Command1Modal
        open={command1ModalOpen}
        onClose={() => setCommand1ModalOpen(false)}
        onSubmit={handleCommand1}
      />
      <Command2Modal
        open={command2ModalOpen}
        onClose={() => setCommand2ModalOpen(false)}
        onSubmit={handleCommand2}
      />
      {/* ... All Command Modals from wireframe.md */}
    </Box>
  );
};
```

**Key Points:**
- After completing Modal component generation, connect all Modals to AggregatePage without omission
- Add API Endpoints to service layer and handle responses in HAL Spring Data REST format
- Number of Commands in wireframe.md = Number of Buttons = Number of Modals = Number of Handlers (must match)

#### 4. Generate ReadModel/View-related Components

**REQUIRED**: All ReadModels in wireframe.md must be generated without omission.

##### 4.1 Generate Dashboard View Components

- Generate same number of Dashboard components as views analyzed in Step 1
- File location: `src/pages/[ReadModel]View.tsx`
- **Condition**: `dataProjection: 'query-for-aggregate'` and `'queryParameters'` exist in metadata
- **UI Structure**: Strictly comply with ReadModel HTML and fields declared in wireframe.md
- **API Endpoints**: Follow `/views.namePlural` rule

**Dashboard Basic Structure (Core Only):**

```typescript
const [ReadModel]View = () => {
  // 1. Search filter state
  const [filters, setFilters] = useState({});
  const [page, setPage] = useState(1);
  const [data, setData] = useState([]);

  // 2. Search handler
  const handleSearch = () => {
    // Call API Endpoints from wireframe.md
  };

  return (
    <Box>
      {/* Search Panel - based on queryParameters from wireframe.md */}
      <Paper sx=\{{ p: 2.5, mb: 2.5 }}>
        <Typography variant="h6">{/* ReadModel title */}</Typography>
        {/* Search fields from wireframe.md */}
        <Button variant="contained" onClick={handleSearch}>Search</Button>
      </Paper>

      {/* Table - based on fieldDescriptors from wireframe.md */}
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            {/* Field names from wireframe.md */}
          </TableHead>
          <TableBody>
            {/* Render data */}
          </TableBody>
        </Table>
      </TableContainer>

      {/* Pagination */}
      <Box sx=\{{ display: 'flex', justifyContent: 'center', mt: 2.5 }}>
        <Pagination page={page} onChange={(_, value) => setPage(value)} />
      </Box>
    </Box>
  );
};
```

##### 4.2 Connect to Sidebar

- Connect Dashboard to Sidebar in 2-level structure
- **Level 1**: `[Aggregate] (English name)` - Top menu
- **Level 2**: Sub-menu for each ReadModel
- **Routing**: `/[aggregate]/[readmodel]`

**Sidebar navItems Structure (Core Only):**

```typescript
const navItems: NavItem[] = [
  {
    title: 'Order (Order)',  // Aggregate.name (English name)
    icon: <Icon />,
    children: [
      { title: 'Order Management', path: '/order/orders', icon: <Icon /> },
      // Add all ReadModels from wireframe.md as children
      { title: 'ReadModel1 Name', path: '/order/readmodel1', icon: <Icon /> },
      { title: 'ReadModel2 Name', path: '/order/readmodel2', icon: <Icon /> },
    ],
  },
  // Other Aggregates follow same structure
];

// Collapse toggle functionality
const [openMenus, setOpenMenus] = useState<Record<string, boolean>>({});

const handleMenuToggle = (title: string) => {
  setOpenMenus((prev) => ({ ...prev, [title]: !prev[title] }));
};
```

**Key Points:**
- `dataProjection: 'query-for-aggregate'` + `queryParameters` exist: Generate Dashboard component and connect to Sidebar in 2-level structure
- `dataProjection: 'cqrs'` + `fieldDescriptors` exist: Generate Search component and connect to `AggregatePage.tsx`
- Number of ReadModels in wireframe.md = Number of Dashboards = Number of Sidebar menus (must match)

#### 5. Validate and Correct Routing and Endpoints
- Verify and correct if routing information connected to `AggregatePage.tsx` is configured as `/aggregate.namePlural`
- Verify and correct if CRUD API Endpoints declared in services follow REST API standards and are configured as `/aggregate.namePlural`
- Verify and correct if API Endpoints connected to `Modal.tsx` match API Endpoints declared in wireframes

#### 6. Environment Variables and Gateway Configuration
- Apply gateway folder directly if exists in Root; otherwise replace with md file
- Set `VITE_GATEWAY_URL=http://localhost:8088` in `.env`, `.env.development`, `.env.production`
- Specify Frontend route (localhost:3000) in gateway's `application.yaml` routes

#### 7. ERP Essential Features Implementation

**Implementation Process:**
1. Create feature components first
2. Integrate into appropriate pages (Aggregate pages or Main page)

##### 7.1 Export/Import Components

**File Locations:**
```
src/utils/exportUtils.ts
src/utils/importUtils.ts
src/components/common/ExportDialog.tsx
src/components/common/ImportDialog.tsx
```

**Required Functions:**
```typescript
// exportUtils.ts
export const exportToCSV(data: any[], fields: string[], filename?: string): void
export const exportToExcel(data: any[], fields: string[], filename?: string): void
export const exportToXML(data: any[], fields: string[], filename?: string): void
```

**Integration:** Add to all Aggregate list pages' action bar with Export/Import buttons

##### 7.2 Search & Filter Components

**File Locations:**
```
src/components/common/AdvancedSearch.tsx
src/components/common/FilterBuilder.tsx
src/components/common/GroupBySelector.tsx
src/components/common/FavoriteSearch.tsx
src/utils/filterUtils.ts
```

**Required Props:**
```typescript
interface AdvancedSearchProps {
  filters: Filter[];
  groupBy: GroupBy[];
  onFilterChange: (filters: Filter[]) => void;
  onGroupByChange: (groupBy: GroupBy[]) => void;
  availableFields: Array<{ name: string; label: string; type: string }>;
}
```

**Integration:** Add AdvancedSearch component at the top of all Aggregate list pages

##### 7.3 Activities Management Components

**File Locations:**
```
src/components/Activities/ActivitiesDashboard.tsx
src/components/Activities/ActivityCard.tsx
src/components/Activities/ActivityScheduler.tsx
src/components/Activities/ActivityReminder.tsx
```

**Required Props:**
```typescript
interface ActivitiesDashboardProps {
  userId: string;
  activities: Activity[];
  onActivityClick?: (activity: Activity) => void;
}
```

**Integration:** Add to Aggregate pages as needed for activity tracking

##### 7.4 Reports Generation Components

**File Locations:**
```
src/components/Reports/ReportBuilder.tsx
src/components/Reports/ReportViewer.tsx
src/components/Reports/ChartBuilder.tsx
src/components/Reports/PivotTable.tsx
```

**Required Props & Chart.js Setup:**
```typescript
interface ReportBuilderProps {
  model: string;
  availableFields: Array<{ name: string; label: string; type: string }>;
  onSave?: (config: ReportConfig) => void;
}

// Chart.js Registration Required
import { Chart as ChartJS } from 'chart.js';
ChartJS.register(ArcElement, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);
```

**Integration:** Add to Main page (HomePage/DashboardPage) bottom section

##### 7.5 Dashboard Widgets Components

**File Locations:**
```
src/components/Dashboard/Dashboard.tsx
src/components/Dashboard/DashboardWidget.tsx
src/components/Dashboard/WidgetConfig.tsx
src/components/Dashboard/WidgetLibrary.tsx
```

**Required Props:**
```typescript
interface WidgetProps {
  id: string;
  type: 'kpi' | 'chart' | 'list' | 'gauge';
  title: string;
  config: any;
}
```

**Integration:** Add to Main page with react-grid-layout for drag-and-drop

**Integration Summary:**
- **Features 7.1~7.3 (Export/Import, Search/Filter, Activities)**: Integrate into Aggregate list pages
- **Features 7.4~7.5 (Reports, Dashboard)**: Integrate into Main page (HomePage or DashboardPage)

#### 8. Validation and Verification

REQUIRED: Follow validation process defined in `@frontend-troubleshotting-rules`
- Verify file generation (Service/Hook/Type/Page)
- Check wireframe.md-based component generation and connections
- Verify routing configuration
- Check ERP component imports:
   ```bash
   grep -r "import.*ExportDialog\|import.*AdvancedSearch" src/pages/
   ```
   If no results → Step 7 incomplete, execute connection immediately
- Build verification:
   ```bash
   npm run build
   ```
   Fix all errors until build succeeds
- UI operation verification (Export/Import buttons, Advanced Search, etc.)

### Important Requirements
- All component generation must be based on metadata. Components should not be arbitrarily generated by referring to non-existent metadata.
- Generate components only when required metadata fields exist
- Follow dependency order: Types → Services → Hooks → Components
- Favicon errors occur frequently and should be proactively addressed as a preventive measure
- All ERP features must be implemented with TypeScript, proper error handling, and Korean language support
- Add BOM ('\uFEFF') for Korean CSV export